---
title: 《C++ Primer》学习笔记
description: C++ Primer里面不太熟的知识点
#date: 2018-11-22 
#updated: 2018-11-22
categories:
- C++
tags:
- C++
---

## 第一章 开始

### P5
标准库中还定义了其他两个`ostream`对象，名为`cerr`和`clog`。我们通常用`cerr`(被称为标准错误)来输出警告和错误信息，`clog`用来输出程序运行时的一般性信息。
### P13
读取数量不定的输入数据：
```
#include<iostream>
int main()
{
	int sum = 0, value = 0;
    //读取数据直到遇到文件尾，计算所有读入的值的和。
	while (std::cin >> value)
		sum += value; //等价于sum=sum++value
	std::cout << "Sum is :" << sum << std::endl;
    return 0;
}
```
当我们使用一个`istream`对象作为条件时，其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成功。当遇到文件结束符（`end-of-file`），或遇到一个无效的输入时，`istream`对象的状态会变为无效。出于无效状态的`istream`对象会使条件为假。
> **从键盘输入文件结束符**
当以键盘向程序输入数据时，对于如何指出文件结束，不同的操作系统有不同的约定。在Windows系统中，输入文件结束符的方法时Ctrl+Z，然后按Enter或Return。在UNIX系统，包括  Mac OS X系统中，文件结束符输入是Ctrl+D。
### P18
包含来自标准哭的头文件时用尖括号（< >）包围头文件名。对于不属于标准库的头文件用双引号（” ”）包围。  
### P19
> **使用文件重定向**
当你测试程序时，反复从键盘敲入这些销售记录作为程序的输入，是非常乏味的。大多数操作系统支持文件重定向，这种机制允许我们将标准输入和标准输出与命名文件关联起来：
`$ prog <infields >outfile`

例如在Windows下，当程序运行时，每次输入一个字符串，然后输出，如果改用文件重定向，进入到cmd环境下，找到`prog.exe`(假如是`prog.exe`)文件的所在的目录，新建一个`input.txt`，（由文件输入，而不是在屏幕上输入——输入重定向）。在命令提示符下输入`prog.exe <input.txt`回车，会将`input.txt`中的文件内容读出，显示在屏幕上。如果不想显示在屏幕上，在命令提示符下输入`prog.exe <input.txt >output.txt`，结果将存入`output.txt`中，如果想把每次结果追加到`output.txt`中，而不是覆盖，在命令提示符下输入`prog.exe <input.txt >>output.txt`。

# 第I部分 C++基础

## 第2章 变量和基本类型

### P32
指定`signed char`或者`unsigned char`
用`double`不要用`float`
### P35
切勿混用带符号整型和无符号整型
### P36
转义序列
### P37
通过添加前缀和后缀，指定字面值类型
### P41
声明和定义的区别，声明用`extern`关键字，如果在多个文件中使用同一个变量，变量的定义必须且只能出现在一个文件里，其它用到该变量的文件必须对其进行声明
### P42
用户自定义标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母开头，定义在函数体外的标识符不能以下划线开头
### P44
作用域，for循环里`int val = 1;`，`val`定义在for语句内，在for语句之内可以访问val，但是在main函数的其他部分就不能访问它了
作用域操作符`::`，覆盖默认的作用域规则，因为全局作用于本身没有名字，所以`::`左侧为空时，向全局作用于发出请求获取作用域操作符右侧名字对应的变量。不过如果函数有可能用到全局变量，最好不要定义一个同名的局部变量
### P45
引用（左值引用）
### P48
空指针，字面值`nullptr`
### P50
`void*`指针
### P52
指向指针的引用，`int *&r = p;`，要理解`r`的类型，从右往左阅读r的定义，离变量名最近的符号对变量的类型有最直接的影响。
### P53
`const`对象必须初始化
### P54
默认状态下，`const`对象仅在文件内有效。如果想在多个文件之内共享`const`对象，必须在对象的定义之前添加`extern`关键字
### P56
对`const`的引用可能引用一个并非`const`的对象，允许通过其他途径改变它的值，比如
```
#include<iostream>
int main()
{
    int i = 42;
    const int &r = i;
    std::cout<<r<<std::endl;
    i = 43;
    std::cout<<r<<std::endl;
    return 0;
}
```
这段代码就会依次打印42，43
和常量引用一样，指向常量的指针也没规定其所指对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过改指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。
### P57
`const`指针
`const`在*后面表示一直指向，在最前面表示本身是常量
练习题，引入`const`限定符才能初始化常量引用
**顶层const**可以表示任意的对象是常量，**底层const**则与指针和引用等复合类型的部分有关
### P59
常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。
允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量表达式。
`constexpr`声明如果定义了一个指针，仅对指针有效，与指针所指对象无关，关键在于`constexpr`把它所定义的对象置为了顶层`const`
```
const int *p = nullptr;
constexpr int *q = nullptr;
```
注意p和q的区别
### P60
类型别名，传统方法是用关键字`typedef`
新标准是用别名声明
`using SI = Sales_item;`
### P61
`auto`类型
### P62
`decltype`类型指示符，作用，引用，双层括号变成引用
### P65
定义类最后记得加上分号

## 第3章 字符串、向量和数组

### P74
`using std::cin;`
头文件不应包含using声明
### P76
初始化string对象的方式
比如
```
string s2(s1);
string s3("value");
string s4(10, 'c');
```
### P77
`string`的操作，
```
os<<s
is>>s
getline(is, s)
s.empty()
s.size()
```
### P79
`size()`函数返回的是一个`string::size_type`类型
### P80
`string`对象相加
字面值和`string`对象相加，运算的时候两侧至少有一个是`string`，注意字符字面值实际上是由常量字符构成的数组（为了和C兼容的历史原因）
### P82
`cctype`头文件中的函数，判断字符的特性或者改变字符的特性
范围`for`
```
for (declaration: expression)
    statement
```
例如：
```
string str("some string");
for (auto c:str)
    cout<<c<<endl;
```
如果想要改变`string`对象中的字符的值，必须把循环变量定义成引用类型
### P87
标准库类型`vector`，容器
定义和初始化`vector`对象的方法
### P89
如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，会尝试用其他初始化方式，比如
```
vector<string> v8{10, "hi"};
```
大括号就会变成小括号
### P90
`vector`的成员函数`push_back()`
### P91
范围`for`语句体内不应该改变其遍历序列的大小，具体原因在169页
### P95
`string`和`vector`都是迭代器，可以用`.begin()`和`.end()`，注意`end()`指向尾元素的下一位置
一般用`auto`关键字定义
### P96
`*iter`返回迭代器`iter`所指元素的引用，用解引用运算符修改元素
### P97
迭代器类型`vector<int>::iterator`和`vector<int>::const_iterator`
### P98
为了得到`const_iterator`，用`cbegin`和`cend`
C++语言定义的**箭头运算符**（->），把解引用和成员访问结合起来，`it->mem`和`(*it).mem`表达的意思相同
### P100
迭代器算术运算
```
auto mid = vi.begin() + vi.size()/2;
```
迭代器距离的类型是`difference_type`
### P106
数组的`begin()`和`end()`定义在`iterator`头文件里，但不是成员函数
```
int *beg = std::begin(ia);（ia是一个数组）
```
### P107
```
auto n = std::end(arr) = std::begin(arr);
```
两个指针相减的结果类型是`ptrdiff_t`的标准库类型，是一种定义在`cstddef`头文件里的带符号类型
### P109
C风格字符串头文件`cstring`
### P111
使用`string`的`c_str`成员函数返回C风格的字符串
```
string s("Hello World");
const char *str = s.c_str();
```
使用数组初始化`vector`对象，指明拷贝区域的首元素地址和尾后地址就可以了
```
int int_arr[] = {0, 1, 2, 3, 4, 5};
vector<int> ivec(std::begin(int_arr), std::end(int_arr));
```
### P114
使用范围`for`处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型
### P115
如果要用多维数组的指针，可以用`auto`，`begin`，`end`，能实现同样的功能，而且看起来更简洁

## 第4章 表达式

### P123
有的运算符没有之规定求值顺序，比如
```
int i = 0;
cout << i << ' ' << ++i << endl;
```
程序是未定义的，无法推断是先求`++i`还是`i`
### P136
位运算符`~`，`^`
### P139
`sizeof`运算符，两种形式
```
sizeof (type)
sizeof expr
```
### P140
逗号运算符，经常用在for循环里
### P144
命名的强制类型转换
`cast-name<type>(expression)`
`cast-name`有4种
### P146
建议避免使用强制类型转换
### P147
运算符优先级表

## 第5章语句

### P154
空语句就是一个分号
程序的读者已经考虑了默认的情况，只是目前还不用管
### P161
`case`标签必须是整型常量表达式
### P162
`switch`语句注意不要漏写`break`
即使不准备在`default`标签下做任何工作，定义一个`default`标签也是有用的，可以告诉程序的读者已经考虑了默认的情况，只是目前还不用管
### P167
省略传统for语句头中的condition的效果等价于在条件部分写了一个true
### P168
范围`for`
```
for(declaration : expression)
    statement
```
expression表示的是一个序列，序列类型的共同特点是拥有能返回迭代器的`begin`和`end`成员
### P169
范围`for`语句的定义来源于与其等价的传统`for`语句，它预存了`end()`的值
### P172
`goto`语句的用法
### P173
`throw`表达式引发一个异常
`throw runtime_error("错误信息");`
`runtime_error`定义在`stdexcept`头文件里
错误信息可以是`string`对象或者C风格的字符串
### P174
`try`语句块的通用语法形式，`try`里面`throw runtime_error`，然后`catch`，可以看下答案书119页
### P175
`what()`是`runtime_error`类的一个成员函数，返回值是C风格字符串
### P176
异常类的4个头文件`exception`，`stdexcept`，`new`，`type_info`

## 第6章 函数

### P183
定义不带形参的函数，可以写空的形参列表，也可以与C语言兼容用`void`关键字表示没有形参
### P185
将局部变量定义为`static`类型，变成局部静态对象，程序中止才被销毁
### P186
建议在头文件中声明函数，在源文件中定义
### P189
如果函数无需改变应用形参的值，最好将其声明为常量引用，因为非指针、非引用的参数会发生拷贝，比较低效
### P190
一个函数只能返回一个值，可以给函数传入一个额外的引用实参，另其返回额外信息
### P192
尽量把函数不会改变的形参定义成常量引用，详细介绍
### P197
```
int main(int argc, char *argv[])
{...}
```
`argc`是指命令行输入参数的个数，`argv`存储了所有的命令行参数，并且第一个参数`argv[0]`一定是程序的名称
### P197
`initializer_list`头文件里定义了`initializer_list`类型，用于表示相同类型可变数量的形参
### P200
`void`函数如果想在它的中间位置提前退出，可以使用`return;`
### P202
返回局部对象的引用或者指针都是错误的，因为一旦函数完成，局部对象被释放
### P203
函数可以返回花括号包围的值的列表（`vector`对象）
`main`函数如果不是`void`类型，那么必须返回一个值，如果没有`return`语句，编译器会隐式地插入返回0的`return`语句
返回0表示返回成功，其他值表示返回失败，为了使返回值与机器无关，`cstdlib`头文件定义了两个预处理变量`EXIT_FAILURE`和`EXIT_SUCCESS`来表示失败或者成功
### P205
`int (*func(int i))[10];`声明了一个返回数组指针的函数
`auto func(int i) ->int(*)[10]`使用C++11的尾置返回类型简化上述`func`声明的方法
### P207
不允许两个函数除了返回类型外其他所有的要素都相同
### P210
函数重载的时候，一旦在当前作用域中找到了所需的名字，编译器就会忽略掉外层作用域的同名实体
### P211
我们可以为一个或多个形参定义默认值，需要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值
### P212
函数里面的局部变量不能作为默认实参
### P214
内联函数`inline`，相当于在编译过程中直接展开
`constexpr`函数体中必须有且只有一条return语句
### P215
调试帮助
`cassert`头文件里的`assert()`预处理宏，使用一个表达式，如果为假，输出信息并终止程序的运行
可以用`NDEBUG`编写自己的条件调试代码，
```
#ifndef NDEBUG
    cerr<<__func__<<"自己想要打印的信息"endl;
#endif
```
编译器为每个函数定义了`__func__`，存放了函数的名字
此外还有`__FILE__`，`__LINE__`，`__TIME__`，`__DATE__`
### P218
在重载函数集合中的候选函数中寻找最佳匹配
### P220
二义性调用是错误的
### P221
函数指针，作为形参，把函数作为实参
### P223
看一下6.7节的练习题，就能知道函数指针的用途了

##第7章 类

### P231
成员函数通过一个名为`this`的额外的隐式参数来访问调用它的那个对象
`std::string isbn() const { return bookNo; }`
`std::string isbn() const { return this->bookNo; }`
是等价的
成员函数名后面的`const`表示是常成员函数，该函数不能修改对象内的任何成员，只能发生读操作，不能发生写操作
### P235
练习7.8 `read`函数将其`Sales_data`参数定义为普通的引用，而`print`将其定义为常量引用，啥原因
构造函数不能被声明成`const`的
### P237
如果需要默认的行为，那么可以在参数列表后面加上`= default`来要求编译器生成构造函数
有的编译器不支持类内初始值，除了类内初始值，也可以使用初始化列表来初始化类内的每个成员，它定义在冒号和花括号之间
假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，需要在不同的字段使用逗号进行分隔，如下所示：
```
C::C( double a, double b, double c): X(a), Y(b), Z(c)
{
  ....
}
```
```
Sales_data(const std::string &s, unsigned n, double p):
	           bookNo(s), units_sold(n), revenue(p*n) { }
```
效果等价于赋值：
```
Sales_data(const std::string &s, unsigned n, double p):
{ 
    bookNo = s;
    units_sold = n;
    revenue = p*n;
}
```
259页会提到两者的区别，有时候只能用第一种
调用：
`Sales_data data3("978-7-121-15535-2", 100, 128, 109)`
### P238
当某个数据成员被构造函数初始化列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化，比如使用类内初始值初始化
### P241
类可以允许其他类或函数访问它的非公有成员，在类内增加以`friend`关键字开始的函数声明就可以让函数成为它的友元
### P242
友元声明在类内出现的具体位置不限，但最好在类定义开始或结束前的位置集中声明友元
### P244
定义在在类内部的成员函数是自动`incline`的
### P245
在变量的声明中加入`mutable`关键字，`const`成员函数中也能改变它，可以用来追踪成员函数被调用了多少次
### P247
通过区分成员函数是否是`const`的，我们可以对其进行重载，定义一个私有成员函数，常量或者非常量的公有成员函数都调用它
### P249
把类名跟在关键字`class`或`struct`后面声明，这种方法从C语言继承过来，也是合法的
### P250
仅声明类而不定义它，在它声明后定义前是不完全类型，只能在很有限的情景下使用：可以定义指向这种类型的指针或引用，也可以声明（但不能定义）以不完全类型作为参数或者返回类型的函数
### P251
如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员
友元关系不存在传递性
### P252
可以只把一个成员函数声明为友元，不过要仔细组织程序结构
### P253
定义在类外部的成员函数，要把返回类型写完整
### P255
一般来说，内层作用域可以重新定义外层作用域的名字，即使该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字
### P256
作用域运算符调用全局变量，用法`::name`
### P259
这一页提到的，也是237页笔记里面两者的区别，如果成员是`const`、引用、或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初始值
建议使用构造函数初始值，底层效率不一样，很多类中前者直接初始化数据成员，后者则先初始化后赋值
成员的初始化顺序与它们在类定义中的出现顺序一致
### P261
委托构造函数，一个委托构造函数把它自己的一些（或者全部）职责委托给其他构造函数
例如
```
//非委托构造函数
Sales_data(string s, unsigned cnt, double price): bookNo(s), units_sold(cnt), revenue(cnt*price) {}

//构造函数委托给上面的构造函数
Sales_data(string s): Sales_data(s, 0, 0){}
```
### P262
默认构造函数包含若干形参，同时为这些形参提供了默认实参，方式有默认初始化和值初始化。一般情况下都应该为类构建一个默认构造函数
### P264
只允许一步类类型转换
`item`是`Sales_data`对象，`combine()`接受一个`Sales_data`对象
```
string null_book = “9-999-99999-9”;
item.combine(null_book);    //隐式转换
```
`item.combine("9-999-99999-9");`这句是非法的，因为只允许一步类类型转换
可以使用下面的两种方法调用
```
item.combine(string("9-999-99999-9"));    //显式地转换成string，隐式地转换成Sales_data
item.combine(Sales_data("9-999-99999-9"));    //隐式地转换成string，显式地转换成Sales_data
```
### P265
在构造函数前面加上`explicit`，只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的, 而非隐式的，只能用于直接初始化，可以避免不合时宜的类型变换，最好把单参数的构造函数都声明为`explicit`
### P266
聚合类所有成员都是`public`的，没有用户定义的构造函数，没有类内初始值，没有基类，没有`virtual`函数
### P267
还有一种情况，虽然不是聚合类，但是只要满足下面的条件，也是字面值常量类：
数据成员必须都必须是字面值类型。
类必须至少含有一个`constexpr`构造函数。
如果一个数据成员含有类内初始值，则初始值必须是常量表达式；如果成员属于某种类，初始值必须使用该类的`constexpr`构造函数。
类必须使用析构函数的默认定义。
通过前置`constexpr`关键字，就可以声明`constexpr`构造函数，同时：
除了声明为`=default`或者`=delete`以外，`constexpr`构造函数的函数体一般为空，使用初始化列表或者其他的`constexpr`构造函数初始化所有数据成员。
### P269
静态成员变量在类的内部声明，声明时直接通过`static`关键字修饰
静态成员变量在类的外部定义与初始化，语法规则为`Type ClassName::VarName = value;`
静态成员变量不占用类的大小，而是在类外（全局数据区）单独分配空间
静态成员函数属于整个类所有
可以通过类名和对象名访问`public`静态成员函数
静态成员函数只能访问静态成员变量和静态成员函数

#第II部分 C++标准库

##第8章 IO库（这一章以后再细看）

### P278
IO库头文件还有`fstream`,`sstream`
`wchar_t`类型的数据是宽字符
### P279
IO库的条件状态

##第9章 顺序容器

### P292
顺序容器除了`vector`和`string`，还有`deque`双端队列, `list`双向链表, `forword_list`单向链表, `array`固定大小数组
### P295
这页有个容器操作表，比较重要的有`iterator`，`value_type`，`reference`
添加删除`insrert`,`emplace`,`erase`,`clear`
### P296
两个迭代器`begin`和`end`构成迭代器范围
### P298
使用迭代器类型，声明语句用作用域运算符，比如`vector<int>::iterator iter;`
### P299
当不需要写访问时，用`auto`使用`begin`和`cend`
### P299
将一个容器初始化为另一个容器的拷贝
相同类型用`C c1(c2);或C c1=c2`
不同类型用`C c(b,e)`，迭代器`b`,`e`指定范围中的元素的拷贝，比如可以用`.begin()+2`
### P301
`array`必须同时指定元素类型和大小，如`array<int, 10> ia1;`
### P302
`swap(c1,c2)`或者`c1.swap(c2)`用来交换两个容器的元素，`.assign()`用来赋值
### P305
向一个`vector`、`string`或`deque`插入元素会使所有指向容器的迭代器、引用和指针失效
### P308
`insert`三种用法，还有返回值
`emplace`操作将参数直接传递给元素类型的构造函数
### P309
访问元素，顺序容器的成员`front`和`back`分别是首元素和尾元素
### P310
使用`at`成员函数类似下标运算符，但如果越界会抛出异常
### P311
删除元素，`pop_back`, `pop_front`, `erase`两种用法、`clear`
### P313
`forward_list`使用的是`insert_after`、`emplace_after`、`erase_after`， 因为无法在前面插入
### P314
用`resize`改变容器大小
### P318
`vector`、`string`、`deque`需要获取新的内存空间时，通常会分配比新空间需求更大的内存空间作为备用，因此它的`capacity`一定会大于或等于`size`，经过实验，`capacity`的增长是成倍的
分配空间用`reserve`
### P321
构造`string`的其它方法，`string s(s2,…)`、`substr`
### P323
`string`的`append`和`replace`
### P325
`string`里用`find`搜索，找不到返回`npos`(-1)，此外还有`find_first/last_of/not_of`
### P326
`string`里还有`rfind`，从右往左搜索
### P327
`string`里还有`compare`函数，6种参数形式
### P327
`string`和数值的转换，`to_string`和`stoi`、`stod`等
### P329
`stack`、`queue`、`priority_queue`的操作，定义了自己的操作

##第10章 泛型算法

### P336
大多数算法都定义在头文件`algorithm`中，`numeric`中也有一组数值泛型算法
`find`用来查找，接受一对迭代器和一个值，返回指针
### P337
`algorithm`里的`count`，接受一对迭代器和一个值，返回出现的次数
### P338
`numeric`中的`accumulate`，求和，第三个参数决定使用哪个加法运算符和返回类型
### P339
`equal`用来确定两个序列是否保存相同的值，接受3个参数，第一个序列的首和尾以及第二个序列的首
### P340
`fill`接受一对迭代器和一个值，赋值给每个元素
`fill_n`接受一个单迭代器，一个计数值和一个值
### P341
用算法向容器中写数据，`back_inserter`定义在头文件`iterator`中，接受一个指向容器的引用，返回一个插入迭代器，通过其赋值时，会调用`push_back`将一个具有给定值的元素添加到容器中
`copy`接受3个迭代器，前两个代表输入范围，第三个表示目的序列的起始位置，返回目的位置迭代器（递增后）的值
### P342
`replace`算法接受4个参数，前两个迭代器表示输入序列，后两个一个是要搜索的值，一个是新值
`replace_copy`额外接受第三个迭代器参数，指出调整后序列的保存位置，保留原序列不变。比如可以用`back_inserter(ivec)`
10.7的b题，泛型算法对于容器的要求并不是有足够的空间，而是足够的元素
### P343
`sort`接受两个迭代器，排序。
`unique`接受两个迭代器，将**相邻的**重复项消除，返回一个指向不重复值范围末尾的迭代器，此位置之后的元素仍然存在，可以用`erase`删除
### P345
向算法传递函数，可以自己定义一个比较函数，作为`sort`的第三个参数
`stable_sort`是稳定排序算法，能维持相等元素的原有顺序
`partition`对容器内容进行划分，使谓词为`true`的排在容器前半部分，而为`false`的在后半部分，返回的迭代器指向最后一个使谓词为`true`的元素之后的位置
### P346
lambda表达式形式：
`[capture list](paramater list) -> return type{function body}`
capture list是一个lambda所在函数中定义的局部变量的列表，捕获列表和函数体不可缺少
### P348
`find_if`可以利用lambda查找第一个满足给定条件的元素的迭代器
`for_each`第一个参数是起始迭代器，第二个参数是终止迭代器，第三个参数是回调函数
### P350
值捕获和引用捕获的区别
### P351
隐式捕获，在捕获列表中写一个&或=
### P352
值捕获的变量的值如果要修改，要在参数列表首加上关键字`mutable`
### P353
`transform`函数的作用是：将某操作应用于指定范围的每个元素。transform函数有两个重载版本：
```
transform(first,last,result,op);//first是容器的首迭代器，last为容器的末迭代器，result为存放结果的容器，op为要进行操作的一元函数对象或sturct、class。
transform(first1,last1,first2,result,binary_op);//first1是第一个容器的首迭代 器，last1为第一个容器的末迭代器，first2为第二个容器的首迭代器，result为存放结果的容器，binary_op为要进行操作的二元函数 对象或sturct、class。
```
如果一个lambda体包含`return`之外的任何语句，则编译器假定此lambda返回`void`。可以使用尾置返回类型为lambda指定返回类型
### P355
标准库bind函数定义在头文件`functional`中，用来参数绑定，名字`_n`定义在一个名为`placeholders`的命名空间里，它本身定义在`std`命名空间里，可以用`using std::placeholders::_1;`或者`using namespace std::placeholders;`
`auto g = bind(f, a, b, _2, c, _1);`此`bind`调用会将`g(_1, _2)`映射为`f(a, b, _2, c, _1)`
即调用`g(X, Y)`会调用`f(a, b, Y, c, X)`
### P357
头文件`functional`里的函数`ref`返回一个对象，包含给定的引用，此对象是可以拷贝的。`cref`函数生成一个保存`const`引用的类
### P358
三种插入迭代器`back_inserter`，`front_insert`，`inserter`
### P359
`unique_copy`相比`unique`多接受第三个迭代器，表示拷贝的目的位置
### P359~363
流迭代器，以后再细看
### P363
反向迭代器`rbegin`，`rend`，`crbegin`，`crend`，用++是反向，放到`sort`里会递减排序
### P369
对于`list`和`forword_list`，应该优先使用成员函数版本的算法，`merge`，`remove`，`sort`，`unique`
### P370
`splice`和`splice_after`

### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
