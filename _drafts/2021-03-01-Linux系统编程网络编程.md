---
title: 2021-03-01-Linux系统编程网络编程
description: 常用的函数
#date: 2018-11-22 
#updated: 2020-07-25
categories:
- Linux
tags:
- Linux
---

## Linux系统编程

### GCC

```shell
gcc test.c -E -o test.i			//预处理
gcc test.i -S -o test.s			//编译
gcc test.s -c -o test.o			//编译、汇编，不进行链接
gcc test.o -o test.out			//链接成可执行程序
```

编译选项还有

```shell
-I directory	//指定include包含文件的搜索目录
-g				//生成调试信息
-w				//禁止所有警告信息(不建议使用)
-Wall			//开启大部分警告提示(建议使用)
-Werror			//视警告为错误;出现任何警告即放弃编译
-D				//指定一个宏
-l library		//连接名为library的库文件
-Idir			//在头文件搜索路径列表中添加 dir 目录
-Ldir			//在 -l 选项库文件搜索路径列表中添加 dir 目录
-O0				//不优化
-O1				//优化.对于大函数,优化编译占用稍微多的时间和相当大的内存.
-O2				//多优化一些.除了涉及空间和速度交换的优化选项,执行几乎所有的优化工作.例如不进行循环展开(loop unrolling)和函数内嵌(inlining).和-O选项比较,这个选项既增加了编译时间,也提高了生成代码的运行效果.
-O3				//优化的更多.除了打开-O2所做的一切,它还打开了-finline-functions选项
-fpic			//如果支持这种目标机,编译器就生成位置无关目标码.适用于共享库(shared library).
-fPIC			//如果支持这种目标机,编译器就输出位置无关目标码.适用于动态连接(dynamic linking),即使分支需要大范围 转移.
-ansi			//支持符合ANSI标准的C程序
-std=c99		//C99标准
-std=c++11		//支持c++11

```

### GDB
https://blog.csdn.net/freeking101/article/details/54406982

### 静态库和动态库

静态库(libxxx.a)在链接的时候就被复制到了程序中。

动态库(libxxx.so)运行时系统动态地加载到内存里。

静态库制作：

```
1. gcc获得.o文件
2. 将.o文件打包，用ar（archive）工具
	ar rcs libxxx.a xxx.o xxx.o
	//r - 将文件插入备份文件中
	//c - 建立备份文件
	//s - 索引
```

静态库使用：

```shell
提供库文件的同时，也需要提供头文件
main.c
lib/libcalc.a
include/head.h
src/...		//这些打包成了libcalc.a就不需要了

gcc main.c -o app -I ./include/ -l calc -L ./lib
```

动态库制作：

```shell
gcc -c -fpic/fPIC a.c b.c
gcc -shared a.o b.o -o libcalc.so
```



动态库使用：

```shell
gcc main.c -o app -I ./include -l calc -L ./lib		//发现动态库加载失败
```

`ldd`（list dynamic dependencies）命令检查动态库依赖关系。

`ldd main`

改环境变量，临时设置

`export LD_LIBRARY_PATH = $LD_LIBRARY_PATH:/路径` 

还有三种永久设置的方法



静态库动态库对比

静态库链接是将需要的二进制代码拷贝到可执行文件中。动态库仅拷贝一些重定位和符号表信息，目标代码最终和可执行文件在一起。

静态库加载速度快，发布程序时无需提供静态库，移植方便。

静态库消耗系统资源，浪费内存，更新部署发布麻烦。

动态库可以实现进程间资源共享，更新部署发布简单，可以控制何时加载动态库。

动态库加载速度比静态库慢一点，发布程序是需要提供依赖的动态库。

### 文件IO

标准C库函数，f开头，返回`FILE *fp`是一个结构体，里面有文件描述符，文件读写指针位置，I/O缓冲区（内存地址）。

缓冲区作用提高效率，`fflush`刷新缓冲区，`printf()`要`\n`拆刷新缓冲区。

一个进程的虚拟地址空间

MMU将虚拟地址映射到真实地址

内核区，用户区

内核区是内存管理，进程管理，设备驱动管理，VFS虚拟文件系统

|       以下是用户区       |
| :----------------------: |
|         环境变量         |
|        命令行参数        |
|          栈空间          |
|          共享库          |
|          堆空间          |
| .bss 未初始化的全局变量  |
| .data 已初始化的全局变量 |
|       .text 代码段       |
|    0-4k  受保护的地址    |



PCB进程控制块是一个结构体（文件描述符，进程ID等），对应一块内存，结构体里有一个数组，文件描述符表。文件描述符有效范围默认0-1023，文件描述符表前3个默认被占用（标准输入，标准输出，标准错误）。