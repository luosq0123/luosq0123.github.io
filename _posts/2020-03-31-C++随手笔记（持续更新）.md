---
title: C++随手笔记
description: 持续更新
date: 2020-03-31 
updated: 2020-11-16
categories:
- C++
tags:
- C++
---

&emsp;&emsp;在知乎上看到一个回答[C++ 有多难？ - 纸条的回答 - 知乎](https://www.zhihu.com/question/30196513/answer/563560938)，评论里面提到第一个问题的另一种写法，确实比较巧妙，代替四个函数的重载
```cpp
Teacher(std::string n, std::string p)
: name(std::move(n)), position(std::move(p)) {}
```
&emsp;&emsp;这种方法会多一次`std::string`的移动构造函数调用，但对性能的影响很小

***

## 使用标准库chrono计算程序运行时间
&emsp;&emsp;以前通常用`ctime`头文件中的`clock`计算程序运行时间
```cpp
clock_t startTime,endTime;
startTime = clock();//计时开始

//run code

endTime = clock();//计时结束
cout << "The run time is: " <<(double)(endTime - startTime) / CLOCKS_PER_SEC << "s" << endl;
```
&emsp;&emsp;但是精度很低，好在C++11之后有了`chrono`
&emsp;&emsp;`chrono`是C++11新加入的方便时间日期操作的标准库，它既是相应的头文件名称，也是`std`命名空间下的一个子命名空间，所有时间日期相关定义均在`std::chrono`命名空间下。通过这个新的标准库，可以非常方便进行时间日期相关操作。
```cpp
auto t1 = std::chrono::steady_clock::now();
//run code
auto t2 = std::chrono::steady_clock::now();

//毫秒级
double dr_ms = std::chrono::duration<double, std::milli>(t2 - t1).count();

//微秒级
double dr_us = std::chrono::duration<double, std::micro>(t2 - t1).count();

//纳秒级
double dr_ns = std::chrono::duration<double, std::nano>(t2 - t1).count();

//秒
double dr_s = std::chrono::duration<double>(t2 - t1).count();
```

***

&emsp;&emsp;STL提供了两个用来计算排列组合关系的算法，分别是`next_permutation`和`prev_permutation`。下面的例子是《剑指Offer》的38题赖皮的方法，输入一个里面可能有重复字符的字符串，返回它的所有排列，里面不能有重复元素。
```cpp
class Solution {
public:
    vector<string> permutation(string s) {
        vector<string> res;
        sort(s.begin(), s.end());
        do{
            res.push_back(s);
        }while(next_permutation(s.begin(), s.end()));
        return res;
    }
};
```

***

&emsp;&emsp;`sort`中的比较函数`compare`要声明为静态成员函数或全局函数，不能作为普通成员函数，否则会报错。 因为：非静态成员函数是依赖于具体对象的，而`std::sort`这类函数是全局的，因此无法在`sort`中调用非静态成员函数。静态成员函数或者全局函数是不依赖于具体对象的, 可以独立访问，无须创建任何对象实例就可以访问。同时静态成员函数不可以调用类的非静态成员。