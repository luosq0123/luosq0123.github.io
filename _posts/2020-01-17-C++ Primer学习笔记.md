---
title: 《C++ Primer》学习笔记
description: C++ Primer里面以前不太熟的知识点
#date: 2018-11-22 
updated: 2020-04-01
categories:
- C++
tags:
- C++
---

## 第一章 开始

### P5
标准库中还定义了其他两个`ostream`对象，名为`cerr`和`clog`。我们通常用`cerr`(被称为标准错误)来输出警告和错误信息，`clog`用来输出程序运行时的一般性信息。
### P13
读取数量不定的输入数据：
```
#include<iostream>
int main()
{
	int sum = 0, value = 0;
    //读取数据直到遇到文件尾，计算所有读入的值的和。
	while (std::cin >> value)
		sum += value; //等价于sum=sum++value
	std::cout << "Sum is :" << sum << std::endl;
    return 0;
}
```
当我们使用一个`istream`对象作为条件时，其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成功。当遇到文件结束符（`end-of-file`），或遇到一个无效的输入时，`istream`对象的状态会变为无效。出于无效状态的`istream`对象会使条件为假。
> **从键盘输入文件结束符**
当以键盘向程序输入数据时，对于如何指出文件结束，不同的操作系统有不同的约定。在Windows系统中，输入文件结束符的方法时Ctrl+Z，然后按Enter或Return。在UNIX系统，包括  Mac OS X系统中，文件结束符输入是Ctrl+D。

### P18
包含来自标准哭的头文件时用尖括号（< >）包围头文件名。对于不属于标准库的头文件用双引号（” ”）包围。  
### P19
> **使用文件重定向**
当你测试程序时，反复从键盘敲入这些销售记录作为程序的输入，是非常乏味的。大多数操作系统支持文件重定向，这种机制允许我们将标准输入和标准输出与命名文件关联起来：
`$ prog <infields >outfile`

例如在Windows下，当程序运行时，每次输入一个字符串，然后输出，如果改用文件重定向，进入到cmd环境下，找到`prog.exe`(假如是`prog.exe`)文件的所在的目录，新建一个`input.txt`，（由文件输入，而不是在屏幕上输入——输入重定向）。在命令提示符下输入`prog.exe <input.txt`回车，会将`input.txt`中的文件内容读出，显示在屏幕上。如果不想显示在屏幕上，在命令提示符下输入`prog.exe <input.txt >output.txt`，结果将存入`output.txt`中，如果想把每次结果追加到`output.txt`中，而不是覆盖，在命令提示符下输入`prog.exe <input.txt >>output.txt`。

# 第I部分 C++基础

## 第2章 变量和基本类型

### P32
指定`signed char`或者`unsigned char`
用`double`不要用`float`
### P35
切勿混用带符号整型和无符号整型
### P36
转义序列
### P37
通过添加前缀和后缀，指定字面值类型
### P41
声明和定义的区别，声明用`extern`关键字，如果在多个文件中使用同一个变量，变量的定义必须且只能出现在一个文件里，其它用到该变量的文件必须对其进行声明
### P42
用户自定义标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母开头，定义在函数体外的标识符不能以下划线开头
### P44
作用域，for循环里`int val = 1;`，`val`定义在for语句内，在for语句之内可以访问val，但是在main函数的其他部分就不能访问它了
作用域操作符`::`，覆盖默认的作用域规则，因为全局作用于本身没有名字，所以`::`左侧为空时，向全局作用于发出请求获取作用域操作符右侧名字对应的变量。不过如果函数有可能用到全局变量，最好不要定义一个同名的局部变量
### P45
引用（左值引用）
### P48
空指针，字面值`nullptr`
### P50
`void*`指针
### P52
指向指针的引用，`int *&r = p;`，要理解`r`的类型，从右往左阅读r的定义，离变量名最近的符号对变量的类型有最直接的影响。
### P53
`const`对象必须初始化
### P54
默认状态下，`const`对象仅在文件内有效。如果想在多个文件之内共享`const`对象，必须在对象的定义之前添加`extern`关键字
### P56
对`const`的引用可能引用一个并非`const`的对象，允许通过其他途径改变它的值，比如
```
#include<iostream>
int main()
{
    int i = 42;
    const int &r = i;
    std::cout<<r<<std::endl;
    i = 43;
    std::cout<<r<<std::endl;
    return 0;
}
```
这段代码就会依次打印42，43
和常量引用一样，指向常量的指针也没规定其所指对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过改指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。
### P57
`const`指针
`const`在*后面表示一直指向，在最前面表示本身是常量
练习题，引入`const`限定符才能初始化常量引用
**顶层const**可以表示任意的对象是常量，**底层const**则与指针和引用等复合类型的部分有关
### P59
常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。
允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量表达式。
`constexpr`声明如果定义了一个指针，仅对指针有效，与指针所指对象无关，关键在于`constexpr`把它所定义的对象置为了顶层`const`
```
const int *p = nullptr;
constexpr int *q = nullptr;
```
注意p和q的区别
### P60
类型别名，传统方法是用关键字`typedef`
新标准是用别名声明
`using SI = Sales_item;`
### P61
`auto`类型
### P62
`decltype`类型指示符，作用，引用，双层括号变成引用
### P65
定义类最后记得加上分号

## 第3章 字符串、向量和数组

### P74
`using std::cin;`
头文件不应包含using声明
### P76
初始化string对象的方式
比如
```
string s2(s1);
string s3("value");
string s4(10, 'c');
```
### P77
`string`的操作，
```
os<<s
is>>s
getline(is, s)
s.empty()
s.size()
```
### P79
`size()`函数返回的是一个`string::size_type`类型
### P80
`string`对象相加
字面值和`string`对象相加，运算的时候两侧至少有一个是`string`，注意字符字面值实际上是由常量字符构成的数组（为了和C兼容的历史原因）
### P82
`cctype`头文件中的函数，判断字符的特性或者改变字符的特性
范围`for`
```
for (declaration: expression)
    statement
```
例如：
```
string str("some string");
for (auto c:str)
    cout<<c<<endl;
```
如果想要改变`string`对象中的字符的值，必须把循环变量定义成引用类型
### P87
标准库类型`vector`，容器
定义和初始化`vector`对象的方法
### P89
如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，会尝试用其他初始化方式，比如
```
vector<string> v8{10, "hi"};
```
大括号就会变成小括号
### P90
`vector`的成员函数`push_back()`
### P91
范围`for`语句体内不应该改变其遍历序列的大小，具体原因在169页
### P95
`string`和`vector`都是迭代器，可以用`.begin()`和`.end()`，注意`end()`指向尾元素的下一位置
一般用`auto`关键字定义
### P96
`*iter`返回迭代器`iter`所指元素的引用，用解引用运算符修改元素
### P97
迭代器类型`vector<int>::iterator`和`vector<int>::const_iterator`
### P98
为了得到`const_iterator`，用`cbegin`和`cend`
C++语言定义的**箭头运算符**（->），把解引用和成员访问结合起来，`it->mem`和`(*it).mem`表达的意思相同
### P100
迭代器算术运算
```
auto mid = vi.begin() + vi.size()/2;
```
迭代器距离的类型是`difference_type`
### P106
数组的`begin()`和`end()`定义在`iterator`头文件里，但不是成员函数
```
int *beg = std::begin(ia);（ia是一个数组）
```
### P107
```
auto n = std::end(arr) = std::begin(arr);
```
两个指针相减的结果类型是`ptrdiff_t`的标准库类型，是一种定义在`cstddef`头文件里的带符号类型
### P109
C风格字符串头文件`cstring`
### P111
使用`string`的`c_str`成员函数返回C风格的字符串
```
string s("Hello World");
const char *str = s.c_str();
```
使用数组初始化`vector`对象，指明拷贝区域的首元素地址和尾后地址就可以了
```
int int_arr[] = {0, 1, 2, 3, 4, 5};
vector<int> ivec(std::begin(int_arr), std::end(int_arr));
```
### P114
使用范围`for`处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型
### P115
如果要用多维数组的指针，可以用`auto`，`begin`，`end`，能实现同样的功能，而且看起来更简洁

## 第4章 表达式

### P123
有的运算符没有之规定求值顺序，比如
```
int i = 0;
cout << i << ' ' << ++i << endl;
```
程序是未定义的，无法推断是先求`++i`还是`i`
### P136
位运算符`~`，`^`
### P139
`sizeof`运算符，两种形式
```
sizeof (type)
sizeof expr
```
### P140
逗号运算符，经常用在for循环里
### P144
命名的强制类型转换
`cast-name<type>(expression)`
`cast-name`有4种
### P146
建议避免使用强制类型转换
### P147
运算符优先级表

## 第5章语句

### P154
空语句就是一个分号
程序的读者已经考虑了默认的情况，只是目前还不用管
### P161
`case`标签必须是整型常量表达式
### P162
`switch`语句注意不要漏写`break`
即使不准备在`default`标签下做任何工作，定义一个`default`标签也是有用的，可以告诉程序的读者已经考虑了默认的情况，只是目前还不用管
### P167
省略传统for语句头中的condition的效果等价于在条件部分写了一个true
### P168
范围`for`
```
for(declaration : expression)
    statement
```
expression表示的是一个序列，序列类型的共同特点是拥有能返回迭代器的`begin`和`end`成员
### P169
范围`for`语句的定义来源于与其等价的传统`for`语句，它预存了`end()`的值
### P172
`goto`语句的用法
### P173
`throw`表达式引发一个异常
`throw runtime_error("错误信息");`
`runtime_error`定义在`stdexcept`头文件里
错误信息可以是`string`对象或者C风格的字符串
### P174
`try`语句块的通用语法形式，`try`里面`throw runtime_error`，然后`catch`，可以看下答案书119页
### P175
`what()`是`runtime_error`类的一个成员函数，返回值是C风格字符串
### P176
异常类的4个头文件`exception`，`stdexcept`，`new`，`type_info`

## 第6章 函数

### P183
定义不带形参的函数，可以写空的形参列表，也可以与C语言兼容用`void`关键字表示没有形参
### P185
将局部变量定义为`static`类型，变成局部静态对象，程序中止才被销毁
### P186
建议在头文件中声明函数，在源文件中定义
### P189
如果函数无需改变应用形参的值，最好将其声明为常量引用，因为非指针、非引用的参数会发生拷贝，比较低效
### P190
一个函数只能返回一个值，可以给函数传入一个额外的引用实参，另其返回额外信息
### P192
尽量把函数不会改变的形参定义成常量引用，详细介绍
### P197
```
int main(int argc, char *argv[])
{...}
```
`argc`是指命令行输入参数的个数，`argv`存储了所有的命令行参数，并且第一个参数`argv[0]`一定是程序的名称
### P197
`initializer_list`头文件里定义了`initializer_list`类型，用于表示相同类型可变数量的形参
### P200
`void`函数如果想在它的中间位置提前退出，可以使用`return;`
### P202
返回局部对象的引用或者指针都是错误的，因为一旦函数完成，局部对象被释放
### P203
函数可以返回花括号包围的值的列表（`vector`对象）
`main`函数如果不是`void`类型，那么必须返回一个值，如果没有`return`语句，编译器会隐式地插入返回0的`return`语句
返回0表示返回成功，其他值表示返回失败，为了使返回值与机器无关，`cstdlib`头文件定义了两个预处理变量`EXIT_FAILURE`和`EXIT_SUCCESS`来表示失败或者成功
### P205
`int (*func(int i))[10];`声明了一个返回数组指针的函数
`auto func(int i) ->int(*)[10]`使用C++11的尾置返回类型简化上述`func`声明的方法
### P207
不允许两个函数除了返回类型外其他所有的要素都相同
### P210
函数重载的时候，一旦在当前作用域中找到了所需的名字，编译器就会忽略掉外层作用域的同名实体
### P211
我们可以为一个或多个形参定义默认值，需要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值
### P212
函数里面的局部变量不能作为默认实参
### P214
内联函数`inline`，相当于在编译过程中直接展开
`constexpr`函数体中必须有且只有一条return语句
### P215
调试帮助
`cassert`头文件里的`assert()`预处理宏，使用一个表达式，如果为假，输出信息并终止程序的运行
可以用`NDEBUG`编写自己的条件调试代码，
```
#ifndef NDEBUG
    cerr<<__func__<<"自己想要打印的信息"endl;
#endif
```
编译器为每个函数定义了`__func__`，存放了函数的名字
此外还有`__FILE__`，`__LINE__`，`__TIME__`，`__DATE__`
### P218
在重载函数集合中的候选函数中寻找最佳匹配
### P220
二义性调用是错误的
### P221
函数指针，作为形参，把函数作为实参
### P223
看一下6.7节的练习题，就能知道函数指针的用途了

##第7章 类

### P231
成员函数通过一个名为`this`的额外的隐式参数来访问调用它的那个对象
`std::string isbn() const { return bookNo; }`
`std::string isbn() const { return this->bookNo; }`
是等价的
成员函数名后面的`const`表示是常成员函数，该函数不能修改对象内的任何成员，只能发生读操作，不能发生写操作
### P235
练习7.8 `read`函数将其`Sales_data`参数定义为普通的引用，而`print`将其定义为常量引用，啥原因
构造函数不能被声明成`const`的
### P237
如果需要默认的行为，那么可以在参数列表后面加上`= default`来要求编译器生成构造函数
有的编译器不支持类内初始值，除了类内初始值，也可以使用初始化列表来初始化类内的每个成员，它定义在冒号和花括号之间
假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，需要在不同的字段使用逗号进行分隔，如下所示：
```
C::C( double a, double b, double c): X(a), Y(b), Z(c)
{
  ....
}
```
```
Sales_data(const std::string &s, unsigned n, double p):
	           bookNo(s), units_sold(n), revenue(p*n) { }
```
效果等价于赋值：
```
Sales_data(const std::string &s, unsigned n, double p):
{ 
    bookNo = s;
    units_sold = n;
    revenue = p*n;
}
```
259页会提到两者的区别，有时候只能用第一种
调用：
`Sales_data data3("978-7-121-15535-2", 100, 128, 109)`
### P238
当某个数据成员被构造函数初始化列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化，比如使用类内初始值初始化
### P241
类可以允许其他类或函数访问它的非公有成员，在类内增加以`friend`关键字开始的函数声明就可以让函数成为它的友元
### P242
友元声明在类内出现的具体位置不限，但最好在类定义开始或结束前的位置集中声明友元
### P244
定义在在类内部的成员函数是自动`incline`的
### P245
在变量的声明中加入`mutable`关键字，`const`成员函数中也能改变它，可以用来追踪成员函数被调用了多少次
### P247
通过区分成员函数是否是`const`的，我们可以对其进行重载，定义一个私有成员函数，常量或者非常量的公有成员函数都调用它
### P249
把类名跟在关键字`class`或`struct`后面声明，这种方法从C语言继承过来，也是合法的
### P250
仅声明类而不定义它，在它声明后定义前是不完全类型，只能在很有限的情景下使用：可以定义指向这种类型的指针或引用，也可以声明（但不能定义）以不完全类型作为参数或者返回类型的函数
### P251
如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员
友元关系不存在传递性
### P252
可以只把一个成员函数声明为友元，不过要仔细组织程序结构
### P253
定义在类外部的成员函数，要把返回类型写完整
### P255
一般来说，内层作用域可以重新定义外层作用域的名字，即使该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字
### P256
作用域运算符调用全局变量，用法`::name`
### P259
这一页提到的，也是237页笔记里面两者的区别，如果成员是`const`、引用、或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初始值
建议使用构造函数初始值，底层效率不一样，很多类中前者直接初始化数据成员，后者则先初始化后赋值
成员的初始化顺序与它们在类定义中的出现顺序一致
### P261
委托构造函数，一个委托构造函数把它自己的一些（或者全部）职责委托给其他构造函数
例如
```
//非委托构造函数
Sales_data(string s, unsigned cnt, double price): bookNo(s), units_sold(cnt), revenue(cnt*price) {}

//构造函数委托给上面的构造函数
Sales_data(string s): Sales_data(s, 0, 0){}
```
### P262
默认构造函数包含若干形参，同时为这些形参提供了默认实参，方式有默认初始化和值初始化。一般情况下都应该为类构建一个默认构造函数
### P264
只允许一步类类型转换
`item`是`Sales_data`对象，`combine()`接受一个`Sales_data`对象
```
string null_book = “9-999-99999-9”;
item.combine(null_book);    //隐式转换
```
`item.combine("9-999-99999-9");`这句是非法的，因为只允许一步类类型转换
可以使用下面的两种方法调用
```
item.combine(string("9-999-99999-9"));    //显式地转换成string，隐式地转换成Sales_data
item.combine(Sales_data("9-999-99999-9"));    //隐式地转换成string，显式地转换成Sales_data
```
### P265
在构造函数前面加上`explicit`，只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显式的, 而非隐式的，只能用于直接初始化，可以避免不合时宜的类型变换，最好把单参数的构造函数都声明为`explicit`
### P266
聚合类所有成员都是`public`的，没有用户定义的构造函数，没有类内初始值，没有基类，没有`virtual`函数
### P267
还有一种情况，虽然不是聚合类，但是只要满足下面的条件，也是字面值常量类：
数据成员必须都必须是字面值类型。
类必须至少含有一个`constexpr`构造函数。
如果一个数据成员含有类内初始值，则初始值必须是常量表达式；如果成员属于某种类，初始值必须使用该类的`constexpr`构造函数。
类必须使用析构函数的默认定义。
通过前置`constexpr`关键字，就可以声明`constexpr`构造函数，同时：
除了声明为`=default`或者`=delete`以外，`constexpr`构造函数的函数体一般为空，使用初始化列表或者其他的`constexpr`构造函数初始化所有数据成员。
### P269
静态成员变量在类的内部声明，声明时直接通过`static`关键字修饰
静态成员变量在类的外部定义与初始化，语法规则为`Type ClassName::VarName = value;`
静态成员变量不占用类的大小，而是在类外（全局数据区）单独分配空间
静态成员函数属于整个类所有
可以通过类名和对象名访问`public`静态成员函数
静态成员函数只能访问静态成员变量和静态成员函数

#第II部分 C++标准库

##第8章 IO库（这一章以后再细看）

### P278
IO库头文件还有`fstream`,`sstream`
`wchar_t`类型的数据是宽字符
### P279
IO库的条件状态

##第9章 顺序容器

### P292
顺序容器除了`vector`和`string`，还有`deque`双端队列, `list`双向链表, `forword_list`单向链表, `array`固定大小数组
### P295
这页有个容器操作表，比较重要的有`iterator`，`value_type`，`reference`
添加删除`insrert`,`emplace`,`erase`,`clear`
### P296
两个迭代器`begin`和`end`构成迭代器范围
### P298
使用迭代器类型，声明语句用作用域运算符，比如`vector<int>::iterator iter;`
### P299
当不需要写访问时，用`auto`使用`begin`和`cend`
### P299
将一个容器初始化为另一个容器的拷贝
相同类型用`C c1(c2);或C c1=c2`
不同类型用`C c(b,e)`，迭代器`b`,`e`指定范围中的元素的拷贝，比如可以用`.begin()+2`
### P301
`array`必须同时指定元素类型和大小，如`array<int, 10> ia1;`
### P302
`swap(c1,c2)`或者`c1.swap(c2)`用来交换两个容器的元素，`.assign()`用来赋值
### P305
向一个`vector`、`string`或`deque`插入元素会使所有指向容器的迭代器、引用和指针失效
### P308
`insert`三种用法，还有返回值
`emplace`操作将参数直接传递给元素类型的构造函数
### P309
访问元素，顺序容器的成员`front`和`back`分别是首元素和尾元素
### P310
使用`at`成员函数类似下标运算符，但如果越界会抛出异常
### P311
删除元素，`pop_back`, `pop_front`, `erase`两种用法、`clear`
### P313
`forward_list`使用的是`insert_after`、`emplace_after`、`erase_after`， 因为无法在前面插入
### P314
用`resize`改变容器大小
### P318
`vector`、`string`、`deque`需要获取新的内存空间时，通常会分配比新空间需求更大的内存空间作为备用，因此它的`capacity`一定会大于或等于`size`，经过实验，`capacity`的增长是成倍的
分配空间用`reserve`
### P321
构造`string`的其它方法，`string s(s2,…)`、`substr`
### P323
`string`的`append`和`replace`
### P325
`string`里用`find`搜索，找不到返回`npos`(-1)，此外还有`find_first/last_of/not_of`
### P326
`string`里还有`rfind`，从右往左搜索
### P327
`string`里还有`compare`函数，6种参数形式
### P327
`string`和数值的转换，`to_string`和`stoi`、`stod`等
### P329
`stack`、`queue`、`priority_queue`的操作，定义了自己的操作

##第10章 泛型算法

### P336
大多数算法都定义在头文件`algorithm`中，`numeric`中也有一组数值泛型算法
`find`用来查找，接受一对迭代器和一个值，返回指针
### P337
`algorithm`里的`count`，接受一对迭代器和一个值，返回出现的次数
### P338
`numeric`中的`accumulate`，求和，第三个参数决定使用哪个加法运算符和返回类型
### P339
`equal`用来确定两个序列是否保存相同的值，接受3个参数，第一个序列的首和尾以及第二个序列的首
### P340
`fill`接受一对迭代器和一个值，赋值给每个元素
`fill_n`接受一个单迭代器，一个计数值和一个值
### P341
用算法向容器中写数据，`back_inserter`定义在头文件`iterator`中，接受一个指向容器的引用，返回一个插入迭代器，通过其赋值时，会调用`push_back`将一个具有给定值的元素添加到容器中
`copy`接受3个迭代器，前两个代表输入范围，第三个表示目的序列的起始位置，返回目的位置迭代器（递增后）的值
### P342
`replace`算法接受4个参数，前两个迭代器表示输入序列，后两个一个是要搜索的值，一个是新值
`replace_copy`额外接受第三个迭代器参数，指出调整后序列的保存位置，保留原序列不变。比如可以用`back_inserter(ivec)`
10.7的b题，泛型算法对于容器的要求并不是有足够的空间，而是足够的元素
### P343
`sort`接受两个迭代器，排序。
`unique`接受两个迭代器，将**相邻的**重复项消除，返回一个指向不重复值范围末尾的迭代器，此位置之后的元素仍然存在，可以用`erase`删除
### P345
向算法传递函数，可以自己定义一个比较函数，作为`sort`的第三个参数
`stable_sort`是稳定排序算法，能维持相等元素的原有顺序
`partition`对容器内容进行划分，使谓词为`true`的排在容器前半部分，而为`false`的在后半部分，返回的迭代器指向最后一个使谓词为`true`的元素之后的位置
### P346
lambda表达式形式：
`[capture list](paramater list) -> return type{function body}`
capture list是一个lambda所在函数中定义的局部变量的列表，捕获列表和函数体不可缺少
### P348
`find_if`可以利用lambda查找第一个满足给定条件的元素的迭代器
`for_each`第一个参数是起始迭代器，第二个参数是终止迭代器，第三个参数是回调函数
### P350
值捕获和引用捕获的区别
### P351
隐式捕获，在捕获列表中写一个&或=
### P352
值捕获的变量的值如果要修改，要在参数列表首加上关键字`mutable`
### P353
`transform`函数的作用是：将某操作应用于指定范围的每个元素。transform函数有两个重载版本：
```
transform(first,last,result,op);//first是容器的首迭代器，last为容器的末迭代器，result为存放结果的容器，op为要进行操作的一元函数对象或sturct、class。
transform(first1,last1,first2,result,binary_op);//first1是第一个容器的首迭代 器，last1为第一个容器的末迭代器，first2为第二个容器的首迭代器，result为存放结果的容器，binary_op为要进行操作的二元函数 对象或sturct、class。
```
如果一个lambda体包含`return`之外的任何语句，则编译器假定此lambda返回`void`。可以使用尾置返回类型为lambda指定返回类型
### P355
标准库bind函数定义在头文件`functional`中，用来参数绑定，名字`_n`定义在一个名为`placeholders`的命名空间里，它本身定义在`std`命名空间里，可以用`using std::placeholders::_1;`或者`using namespace std::placeholders;`
`auto g = bind(f, a, b, _2, c, _1);`此`bind`调用会将`g(_1, _2)`映射为`f(a, b, _2, c, _1)`
即调用`g(X, Y)`会调用`f(a, b, Y, c, X)`
### P357
头文件`functional`里的函数`ref`返回一个对象，包含给定的引用，此对象是可以拷贝的。`cref`函数生成一个保存`const`引用的类
### P358
三种插入迭代器`back_inserter`，`front_insert`，`inserter`
### P359
`unique_copy`相比`unique`多接受第三个迭代器，表示拷贝的目的位置
### P359~363
流迭代器，以后再细看
### P363
反向迭代器`rbegin`，`rend`，`crbegin`，`crend`，用++是反向，放到`sort`里会递减排序
### P369
对于`list`和`forword_list`，应该优先使用成员函数版本的算法，`merge`，`remove`，`sort`，`unique`
### P370
成员`splice`和`splice_after`

## 第11章 关联容器

### P374
标准库提供8个关联容器，关键字可重复出现名字里都有`multi`，无序集合都以`unordered`开头
### P378
有序容器都必须在关键字类型上定义一个严格弱序，可以看作“小于等于”·
### P379
为了在有序容器中使用自己定义的比较操作，除了自己定义的关键字类型外，还要提供比较操作类型，应为一种函数指针类型，书上的例子`multiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn);`
### P380
`map`的元素是`pair`，有`first`和`second`成员
### P380
有时候函数需要返回一个`pair`，新标准下可以用大括号包围的初始化器来返回对象。较早的C++版本要显式构造返回值。还可以用`make_pair`来生成`pair`对象
### P381
关联容器额外的类型别名：`key_type`，`mapped_type`，`value_type.`
### P382
`set`的迭代器是`const`的
### P384
关联容器的`insert`，`emplace`。不包含重复关键字的容器，添加单一元素的`insert`和`emplace`返回一个`pair`，`first`成员是一个迭代器，指向具有给定关键字的元素；`second`成员是`bool`值，指出元素是插入成功还是已经存在于容器中
### P387
删除元素用`erase`，三种用法，返回值也不同
`map`的下标操作，`c[k]`和`c.at(k)`的区别
### P388
如果我们只关心是否存在而不想插入元素，应该使用`find`或者`count`
`c.lower_bound(k)`返回的迭代器指向第一个关键字不小于`k`的元素，`upper_bound`则是第一个关键字大于`k`的元素
`c.equal_range(k)`返回一个迭代器`pair`，表示关键字等于`k`的范围，不存在的话两个成员均等于`c.end()`
使用方法可以看下后面两页的程序
### P395
无序容器在存储上组织为一组桶，使用一个哈希函数将元素映射到桶。管理操作有桶接口、桶迭代、哈希策略

## 第12章 动态内存
### P400
`memory`头文件中的两种智能指针`shared_ptr`和`unique_ptr`，还有一个伴随类`weak_ptr`
### P401
`shared_ptr`和`unique_ptr`都支持的操作
```
p   //将p用作一个条件判断，若p指向一个对象，则为true
p.get() //返回p中保存的指针
swap(p, q)  //交换p和q中的指针
p.swap(q)
```
`shared_ptr`独有的操作
```
make_shared<T>(args)
shared_ptr<T>p(q)
p = q
p.unique()
p.use_count()
```
使用方法：
`shared_ptr<int> p3 = make_shared<int>(42);`
通常用`auto`：
`auto p6 = make_shared<vector<string>>();`
### P402
无论何时我们拷贝一个`shared_ptr`，计数器都会递增
```
    auto p = make_shared<int>(42);
    cout<<p.use_count()<<endl;
    auto q(p);
    cout<<p.use_count()<<endl;
    cout<<q.use_count()<<endl;
```
会输出
```
1
2
2
```
一旦一个`shared_ptr`的计数器变为0，它就会自动释放自己所管理的对象：
```
auto r = make_shared<int>(42);
r = q;  //递增q指向对象的引用计数，递减r原来指向对象的引用计数，变为0会自动释放
```
### P404
使用动态内存的一个常见原因是允许多个对象共享相同的状态
### P408
如果我们提供了一个括号包围的初始化器，就可以使用`auto`
`auto p1 = new auto(obj);`
如果`new`不能分配所要求的的内存空间，就会抛出一个类型为`bad_alloc`的异常，加上`nothrow`可以阻止它抛出异常，而是返回一个空指针
`int *p2 = new (nothrow) int;`
`bad_alloc`和`nothrow`都定义在头文件`new`中
### P413
定义和改变`shared_ptr`的其他方法，比如
```
shared_ptr<T> p(q, d);
p.reset(q, d)
```
不要混合使用普通指针和智能指针
### P414
也不要使用`get`初始化另一个智能指针或为智能指针赋值
可以使用`reset`来将一个新的指针赋予一个`shared_ptr`:
```
p = new int(1024);//错误：不能将一个指针赋予shared_ptr
p.reset(new int(1024));//正确。p指向一个新对象
```
与赋值类似，reset会更新引用计数，如果需要的话，会释放p的对象。
### P417
看下这页的习题，使用自己的释放操作
### P418
通过调用`release`或`reset`将指针的所有权从一个（非`const`）`unique_ptr`转移到另一个
```
unique_ptr<string> p2(p1.release());
p2.reset(p3.release());
```
`release`只是释放控制权，不会释放内存。
释放内存可以用`reset(nullptr);`
### P420
`weak_ptr`只对`shared_ptr`进行引用，而不改变其引用计数，当被观察的`shared_ptr`失效后，相应的`weak_ptr`也相应失效.
`weak_ptr`可以使用一个非常重要的成员函数`lock()`从被观测的`shared_ptr`获得一个可用的`shared_ptr`管理的对象， 从而操作资源。但当`expired()==true`的时候，`lock()`函数将返回一个存储空指针的`shared_ptr`。
### P425
当我们释放一个指向数组的指针时，空方括号对是必需的
```
typedef int arrT[42];
int *p = new arrT;
delete [] p;
```
### P427
用`allocator`类分配内存，使用方法可以看下430页的练习12.26
### P430
读下这一节的文本查询程序

# 第III部分 类设计者的工具

## 第13章 拷贝控制

### P440
如果一个类的构造函数的第一个参数是自己类类型的引用, 且所有其他参数都有默认值, 那么这就是一个拷贝构造函数.
### P441
直接初始化是编译器选择参数最匹配的构造函数，拷贝初始化是将运算对象拷贝到正在创建的对象中
如果初始化的时候使用等号”=”来初始化一个对象, 那么就是拷贝初始化。用的一定是拷贝构造函数(也有可能用移动构造函数)。
相反, 如果初始化时, 没有用等号”=”, 那么就是直接初始化.
拷贝初始化除了在定义变量时用=会发生外，还有哪些情况呢（其实跟值传递类似）：
- 实参传递给非引用形参
- 返回类型为非引用
- 用花括号列表初始化数组或聚合类（自己回顾聚合类定义） 其实之前我们在用一些容器的函数时就涉及到这方面的知识了，只不过那会还不方便提，我们在调用`insert`或`push`时，进行的是拷贝初始化；用`emplace`时用直接初始化
### P444
在默认情况下（用户没有定义，但是也没有显示的删除），编译器会自动隐式生成一个合成拷贝构造函数和合成拷贝赋值运算符
用户可以使用`delete`来指定不生成拷贝构造函数和拷贝赋值运算符，这样的对象就不能通过值传递，也不能进行赋值运算
`Person& operator= (const Person& p) = delete;`
拷贝构造函数和拷贝赋值运算符的行为比较相似，都是将一个对象的值复制给另一个对象，但是其结果却有些不同，拷贝构造函数使用传入对象的值生成一个新的对象的实例，而拷贝赋值运算符是将对象的值复制给一个已经存在的实例。
拷贝赋值运算符通常返回一个指向其左侧运算对象的引用
练习13.8这样写的原因在454页，防范自赋值操作
### P445
在一个析构函数中，首先执行函数体，然后在隐含阶段按初始化顺序逆序销毁成员。
隐式销毁一个内置指针类型的成员不会delete它所指向的对象。而智能指针是类类型，具有析构函数，因此在析构阶段会被自动销毁
### P446
当指向一个对象的引用或指针离开作用域时，析构函数不会执行
可以看下13.13练习题，习题集P337
### P447
需要析构函数的类也需要拷贝和赋值操作
### P448
需要拷贝操作的类也需要赋值操作，反之亦然
### P449
对具有合成版本的成员函数使用`=default`显式地要求编译器生成合成的版本
使用`=delete`将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝
### P452
通过定义不同的拷贝操作，使自定义的类的行为看起来像一个值或指针。
类的行为像一个值，意味着它应该也有自己的状态。当我们拷贝一个像值的对象时，副本和原对象是完全独立的，改变副本不会对原对象有任何影响，反之亦然。
行为像指针的类共享状态，当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据，改变副本也会改变原对象，反之亦然。
### P453
为了像值，每个`string`指针指向的那个`string`对象，都得有自己的一份拷贝，为了实现这个目的，我们需要做以下三个微小的工作：
定义一个拷贝构造函数，完成`string`的拷贝，而不是拷贝指针
配套的，定义析构函数来释放`string`
定义一个拷贝赋值运算符来释放对象当前的`string`，并从右侧运算对象拷贝`string`
### P454
拷贝赋值运算符要处理自赋值的情况。错误代码中，如果是赋值给自己的情况，delete自己的指针之后，无法再给自己赋值。
### P455
定义行为像指针的类
我们可能觉得拷贝指针就行了嘛，没那么简单，你还是要释放内存啊，而且这个释放内存的时机很重要：只有当最后一个指向string的HasPtr销毁时，才能释放内存，所以啊，我们可以用shared_ptr，这几页，不用智能指针，弄得麻烦些，让大家看看底层怎么实现引用计数
### P459
我们定义了swap函数后，就可以利用它写出更简洁的赋值运算符：
```
HasPtr& HasPtr::operator=(HasPtr rhs)
{
    swap(*this, rhs);
    return *this;
}
```
我们来从头到尾仔细看看发生了什么。
我们来调用一下试试：
`lhs = a;`
这样就调用了赋值运算符：
`a`是通过值传递的方式给赋值运算符的，也就是`a`拷贝了一个副本`rhs`
在函数体中调用`swap`函数交换了二者的数据成员，交换的是指针哦，调用后`this`指向原来`rhs`的内存，现在`rhs`指向原来的`this`内存
`return`语句执行后，`rhs`作为局部对象被销毁，内存也被释放，这个被释放的内存就是原来`this`指向的内存，也就是调用赋值运算符语句中的`lhs`
说了那么多，牛逼的地方在于哪里呢？在于你都不用管内存拷贝释放等事情，把类写好之后保证你调用的方式是最经济有效的。
### P460
拷贝控制示例
我们将建立两个类用于邮件处理，两个类命名为Message和Folder，分别表示邮件消息和消息目录。每个Message对象可以出现在多个Folder中，但是任意给定的Message的内容只有一个副本，这样的话，一条Message的内容改变，则我们从任意Folder来浏览它时看到的都是更新的内容
这一部分的设计比较难，但设计好了后用起来很舒服
### P464
StrVec类的设计，用到了`allocator`
### P471
标准库容器、`string`和`shared_ptr`类既支持移动也支持拷贝；`IO`类和`unique_ptr`类可以移动但不能拷贝
### P471
我们通过&&来获得右值引用，右值引用只能绑定到一个即将销毁的对象，所以啊，我们才能自由地将一个右值引用的资源移动到另一个对象中。
类型 | 表达式  
-|-
左值 | 返回左值引用的函数、赋值、下标、解引用、前置递增递减运算符
右值 | 返回非引用类型的函数、算术、关系、位运算符、后置递增递减运算符
### P472
标准库`move`函数
强行右值，`move`算是一个移动构造函数：
```
int a = 12;
int &&b = std::move(a) //move函数告诉编译器，我们要把这个左值当成右值来处理
```
调用`move`就意味着：除了对`a`赋值或销毁外，我们将不再使用它，例如我们不能把它的值赋给别人。
### P473
为了告诉标准库我们的移动构造函数不会抛出异常，在它的参数列表后指定`noexcept`。
### P474
移动赋值运算符也应该标记为`noexcept`
### P476
只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时（比如自定义的类），编译器才会为它合成移动构造函数或移动赋值运算符
### P478
移动赋值运算符和拷贝赋值运算符可以是同一个函数
### P481
我们通过标准库的`make_move_iterator`函数来将普通迭代器转换为移动迭代器：
### P482
区分移动和拷贝的重载函数通常有两个版本：一个接受`const T&`，另一个接受`T&&`
### P483
我们可以在自己的地盘自己定义的类中阻止这种不合理的方式-我们希望强制左侧运算对象（`this`）是一个左值。
那我们具体该怎么做呢？我们可以在赋值运算符参数列表后面加一个引用限定符，`&`表示`this`指向左值，`&&`表示右值；而且，引用限定符只能用于（非`static`）成员函数，且必须同时出现在函数的声明和定义中
记得我们还可以在参数列表后面放const，表示该函数不能修改类中的成员变量，我们得把&放在const之后
### P485
引用限定符是这样的，重载函数，要不你都加，要不就都不加

## 第14章 重载运算与类型转换

### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
### P
